{"meta":{"title":"有光","subtitle":"","description":"非淡泊无以明志，非宁静无以致远","author":"有光","url":"http://youguang.xyz","root":"/"},"pages":[],"posts":[{"title":"Python传参坑","slug":"Python传参坑","date":"2020-07-08T09:00:00.561Z","updated":"2020-07-08T09:00:00.615Z","comments":true,"path":"2020/07/08/Python传参坑/","link":"","permalink":"http://youguang.xyz/2020/07/08/Python%E4%BC%A0%E5%8F%82%E5%9D%91/","excerpt":"","text":"Python传参坑起初在学习Python中的yield中，以杨辉三角练手。 在网上找到了这样的一串代码 12345L=[1]yield Lwhile True: L=[([0]+L)[m]+(L+[0])[m] for m in range(len(L)+1)]yield L 这段代码很奇妙，通过前后移位继而相加的方式，达到了杨辉三件的每一层。我想把他改写成for循环的方式，但是随着报错的不断深入，感觉对我而言并没有这么简单。 开始踩坑这是最接近正确的代码 1234567891011121314151617181920def yh(): L = [1] yield L while True: L1 = [0] + L L2 = L + [0] L.append(0) for m in range(len(L)): L[m] = (L1[m] + L2[m]) yield Lresults = []n = 0for t in yh(): results.append(t) n = n + 1 if n == 10: breakfor t in results: print(t) 但是出现的问题是：存放结果的results中，一直是多个重复的list，经过调试发现，results中的值跟随着L的变化而变化。每当L被操作的时候，results中的结果也会发生变化。 为了解决这个问题，尝试了很多方法，开始时以为是yield的用法不理解，就一味去了解yield用法，但尽管知道了用法之后还是不能结果以上的问题。仔细想了一下，怀疑是results指向的对象和L所指向的对象是一个地址，所以导致了两者同时变化。事实证明猜想是正确的。 迭代器–yield为了解决列表占用大量内存空间的问题，迭代器就是一种时间换空间的解决方案，迭代器在执行过程中会对类似函数中的代码进行计算，如此一来就节省了空间；下面是yield的特点 特征一：含有return的功能，可以将值返回到调用位置 特征二：会记录“函数”上一次执行的位置，下次迭代时，会从上一个位置继续进行。因此迭代“函数的”内容是会被保存的，而且会记录上一次的执行位置。 于是我开始尝试使用return去解决问题，但是还是无济于事（当时还是没有意识到不是yield的问题）。 填坑又经过一阵子搜索，发现Python中传参和C中的传参大为不同。在C中，默认的传参方式是传值调用。而在Python中，得益于一切皆为对象的原则，所以并没有默认的传参类型。 具体传参方式为： list等可变数据类型为所传参数时，是传地址。即C++中的引用。新变量名称仅仅指向赋值对象的地址（新变量随原参变化） tuple等不可变的数据类型为传值。即复该值后，开始重新赋值。（新变量不随原参变化） 如此一来，解决方法就很明显了，即使用传值。在Python传值需要copy模块。果不其然，使用传值方式后，问腿迎刃而解了。 附正确代码： 123456789101112131415161718192021 def yh(): L = [1] yield L while True: L1 = [0] + L L2 = L + [0] L.append(0) for m in range(len(L)): L[m] = (L1[m] + L2[m]) yield L results = []n = 0for t in yh(): results.append(t) n = n + 1 if n == 10: breakfor t in results: print(t) 战果","categories":[],"tags":[]},{"title":"Python","slug":"Python","date":"2020-06-29T07:15:12.445Z","updated":"2020-06-29T07:15:12.477Z","comments":true,"path":"2020/06/29/Python/","link":"","permalink":"http://youguang.xyz/2020/06/29/Python/","excerpt":"","text":"Python入门前言之前对python比较排斥，一直认为是现在的氛围而已，但是昨天用shell创建一些自动化任务的时候，感觉到脚本语言是如此的方便，远比C来的快，那就学学python！！ Python给我的感觉是很类似C，但是在数据类型方面。要优于C很多，不再需要考虑数据类型。也不再需要考虑高精度。 编程语言尽管语法都不尽相同，但是整体思路都是一样的，并且都可以运行在 同一的软件和硬件上。因此相差不会很大的。（架构什么的暂且不去考虑） 一些小知识Python的确是很方便，但是毕竟是一个解释语言，执行速度一般来说是比不上编译语言的 说一下两种语言的区别： 解释语言：有很多，JavaScrip也是解释语言，这类语言拿到的就是一个源文件，不需要编译直接就可以运行，所以就强制开源了。在执行的过程中，还需要解释器一句一句的去解释，解释完之后在执行，相对较慢。脚本语言也是解释型语言的一种。 编译语言：很经典的就是C了，起初先是由编译器将代码编译成exe文件，因为exe是直接编译的二进制文件，因此执行速度会很快。 基本语法输入输出输入12# 输入name = input();#括号中可以填写文字，用于提示输入。 值得注意的是：如果在绝大多数语言中，字符串都是需要加引号的。因此input()括号内的字符串也是需要加双引号的（单引号亦可） 例如：input(“请输入：”) 输出相对于输入，输出就有点小东西了。 123456789101112131415161718# print用法# 1.没有分号print()# 2.字符串还是需要加引号print(\"hello world\")# 3.转移字符为：\\，初次之外r''引号之间的就是需要原样输出的内容，直接忽略各种转义字符print('I\\'m a boy') print(r\"I'm a boy \\!\\！\")# 4.长文本输入（换行）'''我是内容''' 输出结果中：自动换行！默认是字符串格式print(''' 我是内容''')","categories":[],"tags":[]},{"title":"linux无法解析`$'r'`报错","slug":"linux无法解析`$'r'`报错","date":"2020-06-29T07:15:12.440Z","updated":"2020-06-29T07:15:12.466Z","comments":true,"path":"2020/06/29/linux无法解析`$'r'`报错/","link":"","permalink":"http://youguang.xyz/2020/06/29/linux%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%60$'r'%60%E6%8A%A5%E9%94%99/","excerpt":"","text":"linux无法解析`$’\\r’`报错今天在Windows上编写好shell脚本，在本地测试时成功的，但是当我把脚本放到服务器上，centos的系统上运行时，报错。 我对比了自己的shell文件，并没有发现’$’\\r’‘这个符号，自己很是困惑，把这个关键词放在加上Linux在Google搜索后，才发现时Windows换行符于Linux的换行符不相同的原因导致的！ 在Windows中，换行符是：\\r\\n 而Linux系统中，换行符是：\\n 所以在Linux内肯定没办法执行。我在notepad++中，将CRLF模式切换成LF模式后，顺利解决； 其他解决方案安装插件 1apt install dos2unix # 此插件作用就是解决换行不兼容问题 在这里说一下：CRLF以及LF两者都是换行的意思，一个是在windows下，一个是在Linux下。 其中 CR(Carriage Return) 代表回车，对应字符 &#39;\\r&#39;； LF(Line Feed) 代表换行，对应字符 &#39;\\n&#39;； 有关回车和换行的背景 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33，Linux/Unix下的tty概念也来自于此）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\\n\\r”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\\r”；。一个直接后果是，Unix/Mac系统下的文件在 Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。","categories":[],"tags":[]},{"title":"扫盲字符编码","slug":"扫盲字符编码","date":"2020-06-29T01:49:14.479Z","updated":"2020-06-29T02:08:01.190Z","comments":true,"path":"2020/06/29/扫盲字符编码/","link":"","permalink":"http://youguang.xyz/2020/06/29/%E6%89%AB%E7%9B%B2%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","excerpt":"","text":"扫盲字符编码引言想必大家之前一定 会被字符编码困惑。ASCII，GB2312，Unicode，GB18030等等，或者说大家遇到过文件乱码问题。那么这一系列的编码到底是什么？他们之间又会有什么区别？又为什么产生乱码问题？ 1.背景大家应该知道，我们现在的计算机都是二进制，在通俗的来讲，就是01构成！那么问题来了。我们人类交流的主要方式是语言，而语言往往是由大量的符号构成的，所以很自然的就会想到使用二进制编码，对应到指定的符号，即一个唯一的编码对应一个唯一的符号。在这里说两个概念； 字符集：一堆符号的集合，里面包含了符号，文字，图形符号，数字，甚至可以是表情包。（对于人的字符集合） 字符编码：一套规则。使一个二进制代码对应到一个符号的规则。一串00101010的代码，规则A就可以把他读成：0010 1010（读取两次），而规则B就把他读成：”00101010“ 细心的读者可能有所发现，没错，上面的那些ASCII等，都有自己的字符集和字符编码，其中字符编码就一一对应自己字符集内的所有内容 2.ASCII当初计算机是在美国流行起来的，所以当他们考虑计算机显示文字的问题时，想到的肯定只有字母。于是乎，ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）编码便呼之欲出。 下图便是ASCII表（数字代码和符号的对应关系） 具体规则在ASCII中规定：一个字节所对应一个符号。在计算机中，一个字节包含8位，一个字节所能表示的不同状态也只有：256个()&gt;) 。就像上图：符号A，所对应的数字编码为：0100 0001。 但是需要注意的是在ASCII字符集中，只有128个符号，因此ASCII内，128的对应关系。其中前32个符号，是非显示字符（计算机显示）。 随着计算机的发展到欧洲，由于欧洲人们也有着自己的语言，于是就对ASCII进行了拓展，把剩下的128个也建立了对应关系，来表示欧洲地区的字符，并命名为：EASCII 3.非ASCII编码3.1GBXXXX字符集&amp;编码聪明的各位可能就就要问了，欧洲，美洲都把256个对应关系都用光了，我们大中国怎么办？我们博大精深的文字如何表示？此时此刻，GBXXXX字符集&amp;编码就诞生了！（这里的X仅代表数字）。 GB开头的就是我们中国的字符编码。GB就是国标的首字母大写。下面的图是2312的对应规则。 具体规则： 在GB2312中规定：两个字节所对应一个符号。 Q：为什么ASCII一个字节表示，而GB2312用两个符号表示？ A：亲，因为咱们的字多呀！两个字节可以有65536个对应状态（） 3.2Unicode编码可能又要有人问了，不同国家的字符编码不同，那么如何保证信息的准确性？如果我在中国写好的文档，跑到美国去，那我的文档岂不是要乱了？其实在Unicode没有出世之前的确是这个样子的。随着互联网的出现，全世界的人们都在用自己的语言去共享着信息，如果所使用编码不统一，势必会产生乱码的情况的。 那么只有一个解决方式：将世界上所有的文字都去遵循同一种编码方式。这个方法看样子是不是很难实现？但是他已经被Unicode去实现了，所以Unicode是一个很伟大的编码方式； Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 说人话就是：将世界上所有的符号都纳入其中，并且都有与之对应的关系； （最新的Unicode14.0编码规范要在2021年3月发布，由于疫情故推迟到2021年9月发表。） 3.3 UTF-8编码在Unicode值得注意的是：Unicode仅仅规范了符号的编码方式，但是对于存储的方式并没有对此说明。 因为有的符号仅需要一个字节，有的需要多个字节。比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。如果全都以：四个字节去存储，由于较小值的编码点一般使用频率较高，直接使用Unicode编码效率低下，大量浪费内存空间。UTF-8就是来解决这个问题的。即解决Unicode存储问题。（后面的8就是以8位为单元进行编码） UTF-8的编码规范： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 4.结束至此，计算机表示语言的方式（即编码规范）基本大势已定，绝大多数都是Unicode编码，UTF-8存储。从此以后互联时代得到了飞速发展。全世界人们尽管语言不同，但是表示语言的方式完全统一！使得全球互联，世界互惠，人们互通！故此致敬各位前辈在字符编码上所付出的努力！ 参考文献： ASCII，Unicode 和 UTF-8 By阮一峰的网络日志 UTF-8 By维基百科 字符集和字符编码 By吴秦","categories":[],"tags":[]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2020-06-28T09:58:20.101Z","updated":"2020-06-28T09:58:20.125Z","comments":true,"path":"2020/06/28/hexo搭建博客/","link":"","permalink":"http://youguang.xyz/2020/06/28/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"云服务器hexo搭建踩坑记前言最近网课结束了，之前在阿里云领的服务器安装的是window系统，目的是刷网课，好的是网课结束了，于是乎就又把服务器安装上了centos了，自己水平很菜，有又什么新奇的玩法，就打算那服务当作博客使用。当初使用的博客程序是：wordpress，对于操作来说基本上是傻瓜式的，所以我想试试用Hexo搭建一个博客。 那就再网上找搭建教程，本以为搭建的过程会很顺利，但是我完全高估了自己的水平了，哈哈，错误频出，曾今一度陷入大坑。经过1天的折腾，博客最起码可以访问了。 在这里，我们直接用ftp向云服务传送写好的文档，免去的git安装的操作，配置更加简单。（仅限云服务器，GitHub还是需要git的） 踩坑一:困惑当我在网络上搜索时，网上的都是hexo+GitHub的博客搭建教程（我自己有服务器，其实是不需要用GitHub），刚开始的时候，我跟着一步一步的做，越做越困惑，跟GitHub有什么关系？我有自己的服务器呀！ 所以在这里说一下为什么有GitHub： 首先众所周知，GitHub是全球最大的同性交友网站，起作用就是交友，是用来同步自己的代码的。当然玩法也不止如此。再来看看hexo是什么东东。 Hexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 没错，hexo并不是一个博客程序，而是一个markdown转html等文件的转换工具！！！！明白这一点，就很好说了。 hexo+GitHub的工作原理： ​ 1. 自己在本机写好markdown文档 ​ 2. hexo经过一系列的处理将文件转换成html等文件 通过git远程pull将hexo生成的文件推送到GitHub内。 由于GitHub支持html等文件的渲染和解析，当我们直接访问GitHub中的io域名时，就可以访问到网站了（静态网站）但是有时候GitHub系列的网站在大陆不是很稳定，所以可以结合云服务器来搭建博客。此时云服务器就是一个展示的功能。当我们使用云服务情况下，相比GitHub来展示博客而言，云服务（安装Nginx）会更简便一下。 踩坑二：报错在执行：hexo init 或者是不管执行啥命令都会返回usage， 通过一阵子的搜索，发现了问题！没有在hexo的目录文件下执行hexo命令，直接设置环境环境变量还是可以解决的（我估计时安装hexo不完整，包管理程序安装的软件一般都会自己设置系统变量的） 踩坑三：本地图片测试正常，但是网页上却不再显示问题原因经过测试发现，在md中所写的图片地址，是在public的相对地址，但是在本地的typora软件中，相对的是md的相对地址，而最终网页展示的html文件，因此网页段是相对于html的相对路径。两种参考路径不同，肯定会发生本地显示正常（相对md的相对路径），网页不显示图片（相对html的相对路径） 解决方式：尽管是在 本地编辑md文件，但是写相对地址的时，要参照html的文件写地址（经测试url填写绝对路径时，图片仍然失效） 具体步骤 如下： 将所有的文件放在一个文件夹内，且该文件夹内，又可以细分子文件夹来存放图片； 相对路径时上一个目录下的img文件，这样设置以后能在本地直接看到图片 将img文件同步到public内，如此一来生成的html文件也能够按照相对路径的位置，找到指定的图片。","categories":[],"tags":[]},{"title":"静态博客","slug":"静态博客","date":"2020-06-28T08:55:53.602Z","updated":"2020-06-28T08:55:53.626Z","comments":true,"path":"2020/06/28/静态博客/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"静态博客、动态博客1、静态博客都说静态博客比动态博客响应速度快，页面加载速度快 这是为什么？静态博客又是什么？静态博客主要体现在自己的：“静“字。何为静？我们可以理解成不动。对于计算机而言就是对应的：没有进行操作，因此成为静态！ 那么问题来了，一个博客的功能就是展示文章，网站不不进行任何的运算和操作，我们的博客该怎么运行？ 这就说在点子上了，只有我们提前把网站的相关文件准备好，没错是所有的网页提前发布在网站内，当用户直接访问博客时，会通过URL去定位到指定的文件，再有浏览器进行渲染，就得到了所看到的页面了。在这里就已经把静态博客的概念说完了。 静态博客（网站）：提前将网站的内容准备好，提前放到服务器上面。通过URL直接访问指定文件。 （就像我们在Windows系统的资源管理器的地址栏中，直接输入文件就能打开文件一个道理！） 这就可以理解为什么静态的网页加载速度快的原因了！不需要实时的加载，直接就能访问，所以就快了。目前有很多将多种文件直接渲染成HTML的博客框架，其中最有名的要数：hexo。此外很多Hexo+Github搭配可以做出很好效果的静态博客网站（这种教程网上有很多） 再次总结静态网页的优缺点 优点 更简便更安全 访问速度更快 建站成本极低 缺点 如需其他功能需要第三方插件 不太容易上手，对新手不是很友好 操作比较繁琐 功能相比动态博客，不是很丰富 2.动态博客类比静态博客，静态博客的优缺点就一目了然了！","categories":[],"tags":[]},{"title":"计算机网络","slug":"计算机网络","date":"2020-06-28T08:55:53.515Z","updated":"2020-06-28T08:55:53.540Z","comments":true,"path":"2020/06/28/计算机网络/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"计算机网络端口应用的标识符。作用：有时候IP地址只能确定一台计算机的位置吗，但是计算机内通常会运行着多个应用程序。但是通过端口号就能解决这个问题。 每个数据包内都会含有IP和端口号，IP负责找到计算机的位置，而端口号负责将该数据包传输给计算机内的应用程序。通常情况下，80的端口号是web的端口号。所以当数据达到计算机内之后，会把该数据包传给web的应用处理。 子网掩码类似225.225.225.0的形式，换成二进制就是为：11111111.11111111.11111111.00000000，细心的会发现：这里有24个1，没错。为了简便表示：例如：192.168.1.0/24 ，这就表示了IP的前三段为：192.168.1.xxx的IP地址。 就像屏蔽部分地区的IP时，我们并不能将所有的IP都添加到黑名单。我们只需要IP后加/xx的形式去锁定范围地区的IP，大大的简便了表示方法；其作用就是确定IP的网段范围。IP会和子网掩码结合，结合操作的与运算；所以这就保证了为1的位置的IP内容不变。","categories":[],"tags":[]},{"title":"独立思考","slug":"独立思考","date":"2020-06-28T08:55:53.511Z","updated":"2020-06-28T08:55:53.539Z","comments":true,"path":"2020/06/28/独立思考/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/","excerpt":"独立思考大脑的的两个系统分工 系统1 ​ 系统1往往偏直觉性的功能，比如我们的人脸识别，听觉等等，这些尽管都需要大量的运算，但是所处理的任务是少量的，但是是快速的。就相当于我们计算机中的GPU，专门负责计算，没有太多的逻辑跳转，因此在计算力方面，领先CPU 系统2 系统2的功能更强，它可以执行多种的任务。但是所处的领域更广，相比之下速度远不如系统1，且更吃力。 独立思考什么是独立思考","text":"独立思考大脑的的两个系统分工 系统1 ​ 系统1往往偏直觉性的功能，比如我们的人脸识别，听觉等等，这些尽管都需要大量的运算，但是所处理的任务是少量的，但是是快速的。就相当于我们计算机中的GPU，专门负责计算，没有太多的逻辑跳转，因此在计算力方面，领先CPU 系统2 系统2的功能更强，它可以执行多种的任务。但是所处的领域更广，相比之下速度远不如系统1，且更吃力。 独立思考什么是独立思考 明白了大脑的分工，独立思考的概念就比较好理解了。所谓的缺乏独立思考的能力，无非就是系统2的参与度少。换言之，系统1的思考并称不上独立思考！ 思维定势（惰性）：直接绕过系统2，尽管问题需要思考，但是由于思维惰性，（短路原则）直接使用系统1进行思考 提升独立思考既然知道独立思考的本质，我们相对而言就比较容易得到提高独立思考能力的方式了。 阅读内容的选择 多接触多学习新的领域的知识，这样不仅可以提高自己，又能在学习新东西的过程中强制的动用系统2 养成批判思维 不要局限于找到的数量，尽自己最大的能力去发现。 批判思维有两种： ​ 弱批判思维：怀疑别人 ​ 强批判思维：怀疑自己 这两种思维方式，都要有，强弱没有主次之分，相比之下，强批判性思维更难养成 阅读方式 阅读中思考","categories":[],"tags":[]},{"title":"数据转换","slug":"数据转换","date":"2020-06-28T08:55:53.437Z","updated":"2020-06-28T08:55:53.462Z","comments":true,"path":"2020/06/28/数据转换/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"数据转换在做C语言题目的时候，有遇到了数据转换类型的题目。之前对这方面总是草草代过，今天终于给我了当头一棒。 现在对该数据类型转换总结整理一下 自动数据转换 将一种数据类型付给另一个数据类型的时候 1float f = 100; 这里f是float类型，而100确实int类型，此时编译器会自动把100转换为float类型。 1int i = f; 这时候，编译器就会把f转换成int类型，之后在进行赋值操作。 不同类型数据运程中，规则如下 1编译器会自动把所占内存小的变量类型转换为所占内存多的数据类型，如图所示 强制数据转换非自动转化，而是按照自己的需求制定转换类型 12345678910 规则：(type_name) expression 例如 k = (char)a；实例：#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10,b = 3; double c = (double)a/b //此时仅仅将a转换成double类型，就可以是编译器自动将结果转化成double类型变量&#125; PS：转换数据类型都是临时，并不印象元数据的值！","categories":[],"tags":[]},{"title":"指针变量和变量指针","slug":"指针变量和变量指针","date":"2020-06-28T08:55:53.434Z","updated":"2020-06-28T08:55:53.459Z","comments":true,"path":"2020/06/28/指针变量和变量指针/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88/","excerpt":"","text":"指针变量和变量指针读法规则 原则一：谁在前先读谁；const int* a这里的a就是：常量（const）指针（)。同样：int * const p 这里的p就是指针（）常量（const） 原则二：变量的类型是谁靠近变量名最近，该变量就是改类型，比如说上面的a，距离*近，所以a就是一个变量 变量特征 常量指针：const int* p -&gt; const int ( *p) ,要知道，在C/C++中，* 与变量结合的左右是“解引用”，其值就是该变量所存地址的值，再加上前面的const，我们可以知道：是对p指针所指向的内存中的值为常量。 指针常量：int＊const p -&gt; int * const (p)这里括号中是：P，则是对p的值进行添加常量属性，也就是说：p指向的位置是常量，不可变，而所指向的地址中的数值是可以改变的。常见的p++在这里就不能实现，因为p++就是p=p+1，而这里的p是指针，但是指针是常量所以不可以对p的值进行修改； 常指针常量：const int* const p ,如上，这里的P所指向的内存地址，以及内存地址中所指的值都不会发生改变（常量） 变量在内存位置分布情况：便于理解； 代码：123456789101112#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main() &#123; char a[3], b[3]; char* const p = a; *(p++) = 'b';//在这里：p是const类型，所以p++会报错 p[0] = 'a'; p[3] = b[0];//这里的b[0]没有初始化，会报错 return 0;&#125;","categories":[],"tags":[]},{"title":"思科—网络安全笔记","slug":"思科—网络安全笔记","date":"2020-06-28T08:55:53.319Z","updated":"2020-06-28T08:55:53.354Z","comments":true,"path":"2020/06/28/思科—网络安全笔记/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E6%80%9D%E7%A7%91%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"思科—网络安全笔记目录[TOC] 漏洞漏洞的分类软件漏洞 硬件漏洞 1.缓冲器溢出：软件写数据的时候，超出数据区的边界 范围，导致访问到其他软件的内存数据，可能产生的后果有：系统崩溃，权限提升，数据受损等。 2.未验证输入：在程序输入的入口，恶意者故意输入可以强制改变软件内存分配和异常的缓冲区 3.竞争条件：当软件的输出一依赖于：定时或者是有序时，当未按照正确的顺序或者是正确的时间定时输出时，竞争条件成为漏洞的来源 4.安全验证：软件设计者在自己的程序中使用自己做定义的加密算法，而不是使用公认的加密时，可能会导致加密算法被破解。 5.访问控制问题：控制谁做什么的过程。包括物理访问控制，资源的权限，读取或者是更改文件的权限 许多的漏洞是由：不当的访问控制导致的 6.物理破坏 恶意软件malware的类型 间谍软件：跟踪侦察用户，例如记录键盘，数据捕获等 僵尸软件：构成僵尸网络，为攻击者提供资源 广告程序：投放广告 勒索程序：强制用户解密本机数据，达到勒索的目的 假冒安全软件：通过假官方的提示，欺骗用户安装没必要安装的程序或指令 rootkit:专用于修改系统达到植入后门的目的，大多数rootkit利用软件漏洞，提上自身权限，修改系统设置和检测工具 病毒：附加到软件当中的，随着程序一起运行 特洛伊木马：通常隐藏在图片，游戏，音频中。 蠕虫:利用网络中的漏洞自我复制的恶意代码，不像病毒，蠕虫可以自己运行而不需要“宿主”最大特点，自我复制. 中间人（Mitm）：在中间截取用户的信息，然后在传达用户预先访问的位置 移动中的人：中间人的变种，主要目标是移动设备的攻击，软件：zeus 恶意软件的症状无论系统感染了哪种恶意软件，以下是共有的恶意软件症状： CPU 使用率上升。 计算机运行速度变慢。 计算机时常死机或崩溃。 网络浏览速度变慢。 网络连接中存在无法说明的问题。 文件被修改。 文件被删除。 存在未知文件、程序或桌面图标。 有未知进程正在运行。 程序自行关闭或重新配置。 在用户不知情或未经用户同意的情况下发送邮件。 渗透方法社会工程 WiFi破解 网络钓鱼 漏洞利用：收集信息-&gt;利用信息-&gt;发现漏洞-&gt;利用漏洞 拒绝服务 DOS拒绝式服务攻击大量流量：大量的流量导致系统崩溃 恶意数据包：例如不当的数据格式，导致系统崩溃 DDOS分布式拒绝式服务攻击 —僵尸网络构成SEO（搜索引擎优化）中毒恶意使一个恶意网站在搜索前页，排名更高！ 消减影响1.公司承认错误 2.提高详细的信息 3.确保系统干净，没有后门 4.总结经验 隐私保护保护计算机设备 启用防火墙 安装安全软件 调整计算机安全设置（安全等级） 设置密码保护，密码等级越高越好！ IoT局限于固件的低频更新性，容易受到攻击，避免方式：使IoT独立网络，仅与其他IoT共享 无线安全信息加密 加密时将信息转化成另一种信息形式 加密文件系统：EFS 开放授权OAuth2.0是一种开放授权协议，第三方授权。例如：QQ在线登录酷我音乐的网站 保护组织防火墙类型 网络层防火墙：对IP筛选，审查IP 传输层防火墙：端口过滤 应用层防火墙：应用，服务过滤 情景感知防火墙：对用户、设备进行审查筛选 代路服务器：对Web请求过滤 反向代理服务器：反向代理服务器位于 Web 服务器的前面，用于保护、隐藏、分流和分发对 Web 服务器的访问 网络地址转换器(NAT) - 隐藏或是伪装主机的专用地址 基于主机的防火墙 - 过滤单个计算机的端口，服务等； 端口扫描在网络中，设备上运行的每个应用都分配有一个标识符，该标识符叫做端口号。 作用：此端口号在传输的两端使用，以将正确的数据传递到正确的应用 三种状态：打开，关闭，无答复 防御方法· 相关名词 CSIRT - 安全事件响应组织 IDS - 入侵检测系统：基于规则或者恶意攻击数字签名扫描数据，只能通知网络管理员，仅仅提供检测功能； ​ 由于扫描会降低网速，因此离线使用（交换机将数据转达给IDS进行离线扫描） IPS - 入侵防御系统：能够根据主动原则或签名匹配阻止或拒绝流量 SIEM - 安全信息和事件管理系统：一种用于收集和分析来自网络上的安全设备的安全警报、日志及其他实时和历史数据的软件。","categories":[],"tags":[]},{"title":"多重数组地址关系","slug":"多重数组地址关系","date":"2020-06-28T08:55:53.303Z","updated":"2020-06-28T08:55:53.329Z","comments":true,"path":"2020/06/28/多重数组地址关系/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E5%A4%9A%E9%87%8D%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E5%85%B3%E7%B3%BB/","excerpt":"","text":"多重数字地址关系（从内存地址角度分析数组存储情况，弱化了值在数组存在的方式） 1. 一维数组​ 在一维数组中，int arr[2]，在这个声明中，arr也是指针类型，arr所指向的地址就是：a[0]所在的地址。值得注意的是：a[0]的类型是具体的值，一种不严谨的说法：arr=&amp;a[0]=&amp;a(均是指针) 2. 多重数组​ 以二维数组为例，int arr[2][2]，其中a,a[0],均是指针，且同时指向统同一内存地址。也就是数组在内存中的第一个起始地址。但是a[0][0]中所存的值就不再是指针类型，而是一个具体的int类型； 不太严谨的说法：arr = arr[0] = &amp;a = &amp;a[0] = &amp;a[0][0](均是指针) ​ 对比一维数组而言，多重数组的前n-1都是指针类型。就比如说，二维数组这里的n=2，因此有两个指针类型的变量，也即是数组名，和数组名加一维特性。","categories":[],"tags":[]},{"title":"基础语句","slug":"基础语句","date":"2020-06-28T08:55:53.234Z","updated":"2020-06-28T08:55:53.259Z","comments":true,"path":"2020/06/28/基础语句/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"C++相比C中的改进for循环C++中的For循环变得更加简洁，对For进行了扩增，就像Python中的for一样； 12345678int a[] = &#123;1,3,4&#125;;for (auto i : a)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;//输出结果就是a中的值，其过程就是将a中的所有元素依次赋给i，之后输出i。for (auto &amp;i : a)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;//对数组a中的值进行直接操作，此时for的先决条件变成了：auto &amp;i ,也就是将a中的元素的地址给i，或者是说，i在每次循环的过程中，就是a元素的地址 示例代码： 123456789101112131415161718#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;int main() &#123; int a[] = &#123; 1,2,4,4 &#125;; for (auto i : a) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; for (auto&amp; i : a) &#123; i = 2 * i; &#125; cout &lt;&lt; endl; for (auto i : a) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; If and Switch Statement with an InitializerWhy add an Initializer in If anf Switch? The variable, which ought to be limited in if block, leaks into the surrounding scope (本应限制于if块的变量，侵入了周边的作用域) The compiler can better optimize the code if it knows explicitly the scope of the variable is only in one if block (若编译器确知变量作用域限于if块，则可更好地优化代码)","categories":[],"tags":[]},{"title":"函数重载等","slug":"函数重载等","date":"2020-06-28T08:55:53.209Z","updated":"2020-06-28T08:55:53.246Z","comments":true,"path":"2020/06/28/函数重载等/","link":"","permalink":"http://youguang.xyz/2020/06/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%AD%89/","excerpt":"","text":"函数重载，内敛，默认参数值重载在C++中，两个函数的名称可以相同，编译器可以通过形参的个数，类型进行判断调用哪一个函数； 重载函数就是名字完全一样，但是参数类型、个数或者顺序不一样的函数。重载函数主要用来对付不同类型的数据。 默认参数值默认参数值就是在定义函数的同时给参数赋值。使得参数有初始值。 注意，在使用默认参数值时，只能从函数的右端进行初始化操作，在给含有默认参数值的函数传值的时候，只能是从左往右传值 1234567// 定义int f1(int x, int y ,int z = 1)//这里就是所说的：从右往左进行初始化int f2(int x = 1, int y, int z )//这里就是错误的示范// 传值f1(1,1) 因为z含有默认值，所以这里可以传递两个参数f1(1, 1, 1)// 亦可f1(, 1)// 这里的传值没有从左往右开始，因此会报错 内敛函数 inline目的：解决系统的开销 原理：将inline函数的代码块直接拷贝到调用处。省去了普通函数先从寄存器存值，流程跳转的过程，从而提高了程序效率。 缺点：增加程序的大小 注意：，因此在使用内敛函数的时候，往往是那些：频繁使用且代码量较小的函数 此外：内联函数的处理实在编译器预处理的过程，并且编译器 有权利判断是否 执行内敛操作（编辑器尽自己最大努力去拷贝函数，但是不一定能成功）","categories":[],"tags":[]},{"title":"V2ray流量流通过程","slug":"V2ray流量流通过程","date":"2020-06-28T08:55:53.090Z","updated":"2020-06-28T08:55:53.130Z","comments":true,"path":"2020/06/28/V2ray流量流通过程/","link":"","permalink":"http://youguang.xyz/2020/06/28/V2ray%E6%B5%81%E9%87%8F%E6%B5%81%E9%80%9A%E8%BF%87%E7%A8%8B/","excerpt":"","text":"V2ray流量流通过程代理方式为：全局模式，软件将所有的流量均通过V2ray，但是此时还没有传输到远端服务器 路由方式：全局模式，流经到软件的流量不进行特征判断，均使流量通过远端服务器传输。 代理方式：PAC模式，符合PAC的流量将流入到软件内。（此状态时系统决定是否将来流量包出入给软件） 路由方式：绕过大陆，V2ray对流入的流量进行特征判断，当流量目的地属于大陆地区则使该流量走本机，若不符合就走远端服务器 一个推荐的设置方法：系统代理设置为PAC，V2ray流量设置为全局。此方式的效果是只要通过符合PAC的地址，系统就把流量发送给软件，只要是进入软件的流量都走云端。 之前找了很多PAC的规则，但是都是说法不一，自己只好试了一下，这才得到的方法；在我的软件版本中，使用用户编辑的规则，同步到本地的PAC文件内，会使内容变化，故直接在pac文件内直接编辑即可。pac规则@@ -&gt; 排除|| -&gt; 所有域名均走自定义,例如 : &quot;||baidu.com&quot;, 就代表百度的所有域名均走自定义. 当用户规则无效时，可以直接在pac文件中的任意位置编辑即可。","categories":[],"tags":[]},{"title":"using","slug":"using","date":"2020-06-28T08:55:53.064Z","updated":"2020-06-28T08:55:53.091Z","comments":true,"path":"2020/06/28/using/","link":"","permalink":"http://youguang.xyz/2020/06/28/using/","excerpt":"","text":"uisng , typedef ,define区别using新类型的声明：在我们定义一个常指针常量的变量的时候会输入：const int * const p 很明显这里会输入很长的一段代码； 在C中，可以使用：typedef const int* const MyCCP ​ 这里要注意与define进行区分，define的使用方法是： ​ #define PI 3.14 也就是 #define MACROT something ​ typedef const int* const MyCCP 也就是：typedef Some type NewTypeName 一言蔽之就是：两者定义的位置相反 但是在C++中，引入using就变得显而易见。 例如上面的： typedef const int* const MyCCP。 就可以写成： using MyCCP = const int * const 但是在using中不能使用：using in = std::cin ，是因为using的表达式只能是类型，不能是一个对象！","categories":[],"tags":[]},{"title":"SSH原理","slug":"SSH原理","date":"2020-06-28T08:55:52.997Z","updated":"2020-06-28T08:55:53.027Z","comments":true,"path":"2020/06/28/SSH原理/","link":"","permalink":"http://youguang.xyz/2020/06/28/SSH%E5%8E%9F%E7%90%86/","excerpt":"","text":"SSH原理（非对称加密） 什么是SSH？ ​ SSH是一种协议标准，通常用于主机之间的加密通讯，SSH之前，互联网通讯传输的数据是以明文传输的。 加密 对称加密（私钥加密） 加密使用同一种密钥，此加密方式，在传输过程中能保证信息很难被破破解，但是有一个致命的确定：很难保证密钥不被泄露。原因是：把自己的密钥放在很多服务器上，一点其中的服务器被攻破，那么与其他的服务器通讯时，采用同一种密钥，此时，信息将被泄露。此时产生了：非对称加密； 通讯过程 本地通过密钥加密，发送至服务端 服务端的到信息后，按照同样的密钥解密 非对称加密（公钥加密）：公钥加密，私钥解密。私钥解密，公钥解密，也称公开密钥加密 如果你问我，哪一种算法最重要？ 我可能会回答“公钥加密算法”。 来自:阮一峰的网络日志 此加密方式产生两个密钥，一个是公钥，一个私钥。两者关系：公钥加密后的密文，只能通过对应的私钥进行解密。 验证方式为了防止中间人攻击：攻击者将自己的公共密钥发给客户端，客户端通过此公钥加密后的信息，将被攻击者的私钥解密，如此一来就会导致信息的泄露。所以采取一下验证方式。 1.密码验证 通讯过程： 1.本地段发送数据请求，服务端收到后，将该服务器的公钥发送给服务器 2.本地端收到该密钥后，账号和密码进行加密，加密完成后，发送给服务端 3.服务端收到客户端通过公共密钥的信息，通过在本地于该公共密钥对应的私钥，进行解密，账号密码后，与服务器内的值核对校验 4.当身份验证成功后，将数据返回到客户端 但是弊端是，攻击者可能会采取暴力破解的方式，对密码进行猜解，相对密钥验证方式，被破解的概率较大，原因是，通常情况下，密码的程度达不到密钥的复杂程度。 2.密钥验证 该验证方式首先要求，客户端将本地的公共密钥放在远端 当服务器收到客户端的请求时，服务端会生成一个随机数并匹配该用户上传的公钥，对该随机数R加3密。加密之后发送加密数据到客户端 客户端收到加密信息后，通过自己的私钥，进行解密，得到随机数R，并且将R与会话密钥通过MD5生成摘要，再次发送至服务端 服务端收到该MD5后，也会对自己产生的R和会话密钥生成MD5摘要，继而匹配两个MD5 MD5相同时，建立起此次通讯 RSA算法：非对称加密算法的一种1.什么是RSA加密 RSA是一种非对称加密的加密方式，加密得到的结果1024位，或者是2048位。 在保证加密的安全性的同时，也导致加密过程相对较慢，不适用于多信息的加密过程。 为啥子叫：RSA，闪开，大佬来袭： 因为RSA是由：三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，因此叫做；RAS！ 毫不夸张的说，由计算机的地方就有RAS加密算法。 原理呃。。。。待更吧。。","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2020-06-28T08:55:52.872Z","updated":"2020-06-28T08:55:52.902Z","comments":true,"path":"2020/06/28/Linux/","link":"","permalink":"http://youguang.xyz/2020/06/28/Linux/","excerpt":"","text":"Linux上手文件权限 读[r] 写[w] 执行[x] execxte 命令：ll d rwx rwx rwx d -&gt; 目录 文件类型 第一组：文件的所属用户 第二组：文件的所属组 第三组：其他用户 Linux同Windows一样，都有自己的文件结构，每个文件夹内都存有一类的内容 就像Windows中的Users文件存档是的用户的数据，windows文件内存储的是系统文件，program文件夹内存放的是安装的软件的文件，等等。类似有着的Linux同样的层级关系 boot存放系统启动的相关文件 bin：存放二进制可执行文件 etc：存放系统配置文件 home：存放用户文件 root：超级用户目录 opt：额外安装包 usr：系统应用程序usr/local tmp：临时文件","categories":[],"tags":[]},{"title":"linux comman command","slug":"linux comman command","date":"2020-06-28T08:55:51.434Z","updated":"2020-06-28T08:55:51.461Z","comments":true,"path":"2020/06/28/linux comman command/","link":"","permalink":"http://youguang.xyz/2020/06/28/linux%20comman%20command/","excerpt":"","text":"Linux common command ls 查看当先目录文件 mv 重命名（rename）【file】or【directories】 移动【file】to【directories】 cd 进入指定目录 touch create new file mkdir create new directories rm delete file [-f] force [-r] delete directories","categories":[],"tags":[]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2020-06-28T08:55:51.291Z","updated":"2020-06-28T08:55:51.331Z","comments":true,"path":"2020/06/28/Git学习笔记/","link":"","permalink":"http://youguang.xyz/2020/06/28/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Git笔记1. Git是什么Git是世界上最先进的分布式版本控制系统 Workspace：工作区 Index/Stage：暂存区 Repository：仓库区（本地仓库） Remote：远程仓库 2. 基本操作文件操作： 123456创建文件：touch 文件名.*删除文件：rm 文件名创建文件夹：mkdir 文件夹名删除文件夹：rm -r 文件夹名查看文件：cat 文件名 恢复历史版本 12345git reset --hard HEAD^ 退回上一个版本git reset --hard HEAD^^ 退回上上一个版本git reset --hard HEAD^^^ 退回上上上一个版本git reset --hard HEAD~100 退回第100个版本git reset --hard 版本号 退回版本号版本 (查看版本号:git reflog) 修改相关： 12放弃历史暂存区文件修改：git restorgit chackout -- 文件名 1初始化仓库：git init 1添加文件到暂存区 ：git add filename 1提交文件到仓库：git commit filename 1查看暂存区当前状态：git status 1查看暂存区文件修改情况：git diff 12查看最新文件修改记录：git log 简洁呈现：git log -pretty&#x3D;online查看所有文件更改记录：git reflog 12清空暂存区：git rm --cached filename; re .&#x2F;git&#x2F;index 暂存区文件 分支： 1234创建分支：git branch [分支名称]查看分支：git branch -v切换分支：git checkout [分支名称]合并分支：git merge [要求被合并的分支名称] 远程： 123推送：git push origin master拉取：git pull origin masterpull和clone的区别，pull是拉去远程的某个分支，clone是直接把远程的所有信息都下载下来，比如日志信息，其他分支等 时光穿梭机（版本恢复） 命令说明： git rm 删除工作区文件，并且把删除记录提交到暂存区（git rm[name]相当于：rm + git add[name] ） rm 删除工作区的文件。 恢复的方法： git checkout filename 对于checkout的说明： 情况一：当暂存区存在该文件时，将暂存区文件恢复到工作区 情况二：当暂存区未存在该文件时，将版本库中的文件恢复到工作区 git reset HEAD^ filename 作用：把上一个版本filename拉取到暂存区，此时工作区并不存在该文件，但是当我们执行git checkout filename 文件在工作区就会被找到！ 尝试情况： 情况一：提交到暂存区，不提交文件库 rm删除，工作区文件不存在，暂存区没有同步最新情况 恢复 git checkout filename 工作区恢复成功，来源暂存区，可以看出add是把文件放到暂存区中 git reset HEAD filename 恢复失败（考虑原因是因为没有可恢复的仓库） git rm删除，工作区文件不存在，暂存区更新删除记录，即暂存区该文件执行删除操作 git checkout filename 恢复失败（原因：因为给git rm=rm + add,此时暂存区该文件的记录，因此checkout会尝试在暂存区中恢复文件到工作区，但是暂存区中只有该文件的删除行为，而文件却不存在，因此恢复失败） git reset HEAD^ – filename恢复成功 情况二：提交到暂存区，提交到文件库 rm删除，工作区文件不存在，暂存区存在 git checkout filename 工作区恢复成功 git reset HEAD^ – filename恢复成功 git rm删除 git checkout — filename 恢复失败 git reset HEAD^ filename 此时操作区并未恢复文件 当在执行：git checkout filename 此时，工作区恢复了该文件 3. 错误异常1. 1234执行：git push origin master报错：error: src refspec master does not match any，远程仓库与本地仓库的之前版本不匹配，无法进行不丢失的推送（合并）解决方法：git pull origin master git add git commoit -m &quot;x&quot;将远端的仓库拉下来，并于本地合并，之后再进行网络推送就可以了 解决链接：https://blog.csdn.net/dietime1943/article/details/85682688?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task 2. 123执行：git push origin master报错： Updating an unborn branch with changes added to the index.（使用添加到索引中的更改更新未生成的分支。） 其实也就是本地的仓库没有提交，无法推送远程仓库解决方法：git commit -m &quot;m&quot;&#x2F;&#x2F;作用：把暂存区的操作同步到本地的仓库中 情况一：未commit（有add/无add，均无效） error: failed to push some refs to ‘https://github.com/ymyguang/text.git&#39; 提交后，commit，推送完成 情况二： 本地编辑文件后，GitHub同时编辑文件后，推送本地仓库，失败，此时情况已提交 操作：pull拉取后，要求输入拉取说明。拉取成功。本地文件填充，（非同行） 操作后，再次推送，成功。（怀疑是检测版本号） 尝试使用–rebase ，拉回2.txt，再次提交后，正常，推送正常 尝试本地删除，2.txt,不新建，直接推送，成功 ，新建其他文件，推送，成功！ 尝试修改不同文件：在两端同时修改，此次报错，由此可见：只要远端的版本不是与本地的版本书不匹配，将无法push 分析：如图","categories":[],"tags":[]},{"title":"C语言运算规则","slug":"C语言运算规则","date":"2020-06-28T08:55:51.183Z","updated":"2020-06-28T08:55:51.229Z","comments":true,"path":"2020/06/28/C语言运算规则/","link":"","permalink":"http://youguang.xyz/2020/06/28/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99/","excerpt":"","text":"C语言运算规则语句运算顺序：符号优先级，结合方向 算术运算符结合方向：从左往右 赋值运算符结合方向：从右往左 逗号的值是最后的的值：左结合 运算之后的数据类型，当运算变量数据类型不符是，类型低的自动转换成内存占用高的，（强数据转换），在C中的强数据转换采取：舍去原则；强数据转换是中间值，不印象原来的数据 1234 int/int -&gt; int int/float -&gt;float %的操作数是整数，符号和被除数一致// 所有单位运算都是从右往左算的 C程序的调试过程 编辑 .cpp ,c 源程序文件 编译 .obj 目标文件 链接 .exe 可执行文件 执行","categories":[],"tags":[]},{"title":"Class_Object_instance","slug":"Class_Object_instance","date":"2020-06-28T08:55:51.086Z","updated":"2020-06-28T08:55:51.121Z","comments":true,"path":"2020/06/28/Class_Object_instance/","link":"","permalink":"http://youguang.xyz/2020/06/28/Class_Object_instance/","excerpt":"","text":"C++ Class（类）class -》objects 对象是类的实例化 类的特点：类是一种数据类型 封装 Encapsulation 继承 Inheritance 多态 Polymorphis 类的构成： 数据域（data field）By 变量（ variable） 行为（behavior ） By 函数(Function) 特殊的两种函数 构造函数 constructors ：创建对象时，被自动调用 当类中不含有构造函数时，编译器会自己的创建一个默认构函数（default constructors） 析构函数 destructors ：对象被销毁时，被自动调用 类的用法12345678910111213141516171819202122232425#include &lt;iostream&gt;using std::cin;using std::cout;using std::endl;class Circle &#123;public: double radius; Circle() &#123; radius = 1.0; &#125; Circle(double r) &#123; radius = r; &#125; double getArea() &#123; return (3.14 * radius * radius); &#125;&#125;;int main() &#123; Circle c1; Circle c2&#123; 2.0 &#125;; cout &lt;&lt; c1.getArea() &lt;&lt; endl; cout &lt;&lt; c2.getArea() &lt;&lt; endl; return 0;&#125; 类的成员关系 public关系，类中的成员可以被访问 private关系，成员仅仅允许类内部进行访问","categories":[],"tags":[]},{"title":"C++编译过程","slug":"C++编译过程","date":"2020-06-28T08:55:51.086Z","updated":"2020-06-28T08:55:51.127Z","comments":true,"path":"2020/06/28/C++编译过程/","link":"","permalink":"http://youguang.xyz/2020/06/28/C++%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"C/C++编译过程在学习C++过程中，遇到了头文件为什么最好是包含.h类型，而不是cpp类型的问题。在寻找结果的过程过，发现是跟语言的编译过程有关，借此机会学习一下C/C++的编译过程 目的就是：将高级语言转换成二进制语言，供计算机执行； 2020年6月28日更新前几天我尝试在vs code中，编写多文件的代码文件，但是出现了很多报错情况，经过排查发现，vsc在没有build system的情况下只会编译当前文件，这就导致了多文件没办法被编译，所以当只有这一个编译好的程序文件去尝试连接代码中不存在的变量时，肯定是找到不到的，就爆出了错误。 那么如何去解决在vsc多文件编译的情况？方法是：上文提到的build system（构建系统），目前流行的时：cmark，它可以根据编写规则，生成makefile，之后在去按照makefile去批量编辑多个文件，如此一来，第四阶段的链接才能生效。 多说一句，现在很多都是IDE解决一切，什么都不管直接小三角号，一个三角号就一劳永逸了，时间长了根本无法了解编译的过程，因为所有的东西都被IDE给办了，自己什么都不知道！编程而言，不应该仅仅在表面上 ，还要知道背后的原理，这样才能更容易理解新东西！ 过程1.预处理替换代码中的头文件，宏定义，去除代码注释 1gcc -E text.cpp -o text.i -E：预处理完成后终止编译进行 2.编译此过程中会将预处理之后的代码，翻译特定的汇编代码，通常情况下，当编译器报错语法错误时，就是在这个过程中。 1gcc -S text.cpp -o text.i -S：编译完成后终止编译进行 3.汇编显而易见，就是把上一步转换到的汇编代码，翻译成机器语言 1gcc -c text.cpp -o text.o -c：汇编完成后终止编译进行 4.链接在C/C++中，一定少不了对头文件的引用，当编译器把自己的cpp编译以后，还会链接到cpp中的头文件所对应的,obj文件，如此以来，整个程序才被编译成了可执行文件。 附表： 文件扩展名 文件类型 .c C语言代码 .C、.cc、.cpp C++语言代码 .i 预处理后的C语言代码 .s、.S 汇编语言代码 .o 目标代码 .a 静态链接库(程序编译时使用) .so 动态链接库(程序运行时使用 回到上面的问题： Q：为什么最好是包含.h类型，而不是cpp类型的问题? A：当我们的头文件是cpp文件时，有如下弊端： 当代码文件进行修改后，整个项目都需要重新编译，而当头文件是.h的时候，尽管修改了源代码，但是编译的还是那些代码量，不会在对头文件进行重新编译，之后直接就将编译出来的obj文件，与头文件对应的lib文件进行结合即可。（当整个项目不是很大的时候，二者没有太大的区别，但是当项目大时，这种优势就会很明显了） 当以.h为头文件时，我们就可以很容易的实现库的传播，又能保证代码的闭源。 include &lt;.cpp&gt; 对***.cpp文件重新编译，之后将二者连接 。** #include&lt;*.h&gt; 对.h对应的文件名实现连接。** 再理解：C/C++编译方式是：单元翻译，独立的编译每一个cpp文件，例如a.cpp，b.cpp在同一个项目文件中，因此在编译整个项目的过程中，编译器会独立的编译a.cpp，b.cpp。但是当b.cpp中，，有一个a中的函数，直接引用了a中的函数，此时编译器会不会报错？实际上是不会报错的，只要我们在b.cpp内声明了这个函数，编译器在编译b.cpp的时候，就会生成一个符号表（symbol table）【b中看不见的变量/函数/类等都会存放到这个表格内】，此时编译器在编译完成后，在链接的阶段就会按照符号表中的值对整个项目进行查找。从而实现了源码分离。 12345678通常，在一个 C++ 程序中，只包含两类文件—— .cpp 文件和 .h 文件。其中，.cpp 文件被称作 C++ 源文件，里面放的都是 C++ 的源代码；而 .h 文件则被称作 C++ 头文件，里面放的也是 C++ 的源代码。C++ 语言支持&quot;分别编译&quot;（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中定义了一个全局函数 &quot;void a()&#123;&#125;&quot;，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 &quot;void a()&quot; 函数之前，先声明一下这个函数 &quot;voida();&quot;，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 &quot;void a()&quot; 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。注意这里提到了两个概念，一个是&quot;定义&quot;，一个是&quot;声明&quot;。简单地说，&quot;定义&quot;就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而&quot;声明&quot;则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按 C++ 语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？这种机制给 C++ 程序员们带来了很多好处，同时也引出了一种编写程序的方法。考虑一下，如果有一个很常用的函数 &quot;void f() &#123;&#125;&quot;，在整个程序中的许多 .cpp 文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？能保证每个程序员都可以完完全全地把所有函数的形式都准确地记下来并写出来吗？ 贴一下链接：https://www.runoob.com/w3cnote/cpp-header.html 讲的很清楚！！！ 参考链接： 编译器的工作过程 C语言编译过程详解 C/C++程序编译过程详解","categories":[],"tags":[]}],"categories":[],"tags":[]}